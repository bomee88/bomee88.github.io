---
title : "[패스트캠퍼스 수강 후기] 프론트엔드 인강 100% 환급 챌린지 15회차 미션 - 27강 비동기처리(callback, async, await)"
date : 2020-08-24
categories : fastcampus 
tags : fastcampus all-in-one-challenge day15 javascript 
---
# 비동기 처리란?
동기적 처리는 한 작업이 끝날때까지 다른 작업들은 준비상태로 있기 때문에 대기시간을 잡아먹는다. 반면 비동기적 처리는 동시에 여러가지의 작업을 처리할 수 있어서 대기시간이 없다. 
![비동기 처리](/images/200824-1.png)
그럼 코드로 예시를 한번 보도록 하자.
```javascript
function work(){
  const start = Date.now();
  for (let i = 0; i < 1000000000; i++){

  }
  const end = Date.now();
  console.log(end - start + 'ms');
}
work();
console.log('다음작업'); //1067ms, 다음작업 반환.
```
지금 위의 코드는 work가 1067ms 실행되고 나서 다음작업이 실행되는 것을 보여주는 코드다. 여기서 setTimeout을 사용하면 for문이 돌아가는동안 다음작업을 먼저 실행시킬 수 있다.(= 비동기적 처리)
```javascript
function work(){
  setTimeout(() => {  
    const start = Date.now();
    for (let i = 0; i < 1000000000; i++){
  
    }
    const end = Date.now();
    console.log(end - start + 'ms');
  }, 0);
}
console.log('작업시작');
work(); 
console.log('다음작업');
//작업시작, 다음작업, 1067ms 순서대로 반환.
```
## callback
요것을 callback을 활용해 순서를 좀더 명확히 보도록 해보자.
```javascript
function work(callback){
  setTimeout(() => {  
    const start = Date.now();
    for (let i = 0; i < 1000000000; i++){
  
    }
    const end = Date.now();
    console.log('work 도는 중');
    callback(end - start);
  }, 0);
}
console.log('작업시작'); //작업시작
work((ms) => {
  console.log(`작업이 ${ms}만에 끝났어요!`); 
}); 
console.log('다음작업'); //work가 도는 동안 먼저 실행.
```
![scope](/images/200824-2.png)
위의 사진과 같이 나오는 것을 볼 수 있다.  
이렇게 callback을 통해 work에서 계산한 값을 다음작업을 위해 꺼내올 수 있다.  
이런 비동기적 처리가 필요한 작업은 무엇이 있을까?  
![scope](/images/200824-3.png)
Ajax Web API 요청, 파일읽기, 암호화/복호화의 경우는 요청을 하고 서버에서 응답을 할때까지 대기를 해야하므로 이런 경우 다른 작업을 먼저 실행할 수 있도록 위와 같이 비동기적 처리를 해준다. 혹은 작업을 예약할때, 이 작업은 몇초 뒤에 해야한다 할 경우에도 비동기적으로 setTimeout을 활용해서 처리를 해준다.  
비동기적 처리를 할때 위에서 본 것 처럼 callback함수 외에도 promise, async, await 등을 사용하곤 한다. 이를 더 알아보자.

## promise
promise는 비동기적 처리를 좀 더 편하게 할 수 있도록 ES6에 도입된 기능이다. 코드가 길어질 경우 callback함수를 쓰다보면 복잡해지고 보기 어려워지곤 했다. 그래서 promise를 라이브러리로 끌어서 사용했었는데 편리하다보니까 ES6에 도입이 되었다. 먼저 callback함수를 많이 쓸경우 코드가 어떻게 더러워지는지 봐보자. 
```javascript
//숫자 n을 파라미터로 받아와서 5번에 걸쳐서 1초마다 1씩 더해서 출력하는 함수를 만들어보자.

function increaseAndPrint(n, callback) {
  setTimeout(() => {
    const increased = n + 1;
    console.log(increased);
    if (callback) {
      callback(increased);
    }
  }, 1000);
}

increaseAndPrint(0, (n) => {
  increaseAndPrint(n, (n) => {
    increaseAndPrint(n, (n) => {
      increaseAndPrint(n, (n) => {
        increaseAndPrint(n, (n) => console.log('작업끝!'));
      });
    });
  });
});
// 1,2,3,4,5,작업끝 반환
```
이런 코드를 '콜백지옥'이라고 부른다고 한다.ㅎㅎㅎ  
이제 promise를 사용해서 콜백지옥을 없애보자. 
```javascript
console.log(number);
var number = 3;
// undifined
```
이렇게 쓰면 hoisiting이 발생한 javascript는 아래와 같이 코드를 풀어서 해석한다.
```javascript
var number;
console.log(number);
number = 3;
// undifined
```
그렇기 때문에 undifined가 뜨는 것이다. 반면 const와 let은 hoisting이 발생하지않아 undifined가 아닌 Error와 경고문구를 출력해버린다.
```javascript
console.log(number);
const number = 3;
// Error! number를 먼저 선언하고 불러와라 라는 경고문구.
```
위와 같은 사항을 참고 하고 개발하도록하자.

# 마치면서
var는 여러모로 버려야하는 거구나.. 구형 ie도 같이 소멸해버려라.   
오늘은 여기까지..    
시청 영상 26강 11~12까지
![수강인증이미지](/images/200823-4.jpeg)
   
프론트엔드 개발 올인원 패키지 with React Online. 👉 https://bit.ly/31Cf1hp